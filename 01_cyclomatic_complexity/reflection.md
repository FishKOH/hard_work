### Case №1
#### Описание функции
Функция на основе данных об игровом мире делает выбор точки дальнейшего следования

С помощью game_state имитируется конечный автомат.
В функции закодированы условия перехода в новые состояния.

В зависимости от текущего состояния по разному решается задача выбора точки следования

#### Уменьшение ЦС
| код | ЦС |
| --- | --- |
| [Исходный код](case1/before.py) | 12 |
| [Результирующий код](case1/after.py) | 2 |

1. Избавился от цепочки if elif посредством оформления условий перехода конечного автомата в виде таблицы(словаря).
2. Избавился от цепочки if elif посредством оформления зависимости от текущего состояния по разному решается задача выбора точки следования в виде таблицы(словаря).
3. Избавление от вложенных if посредством рефакторинга логики

### Case №2
#### Описание функции
Вычисляет положение формы на экране пользователя.

#### Уменьшение ЦС
| код | ЦС |
| --- | --- |
| [Исходный код](case2/before.cpp) | 11 |
| [Результирующий код](case2/after.cpp) | 2 |

1. Замена цепочки if else if на табличную логику
2. Замена цикла с вложенным if на декларативный вариант - алгоритм(функция из стандартной библиотеки) std::find_if_not

### Case №3
#### Описание функции
По факту изменения азимута(изменяется периодически от 0 до 360 градусов)
в заданных азимутах необходимо вычислять некую статистику, по заданным для этого азимута правилам.

#### Уменьшение ЦС
| код | ЦС |
| --- | --- |
| [Исходный код](case3/before.cpp) | 10 |
| [Результирующий код](case3/after.cpp) | 3 |

1. Выбор правильного типа: замена пары bool и Azimuth, на optional<Azimuth>
2. Полиморфизм: выделение общей логики вычисления статистики и специализация заданных для этого азимута правил.

#### О кейсе
Не самый удачный кейс, с одной стороны код функции стал более читаемым и ЦС уменьшилась, правда частично ЦС скрылась в методах новых типов (ЦС=3 для `StatisticReport::countReplies`).  
А с другой стороны появились новые типы, выглядищие недостаточно проработанными.
Возможно, это рефакторинг на середине пути, и тут ещё есть над чем поработать.

### Резюме
Первым делом разобрался как вычислять ЦС, 
- по графу потока выполнения(Control Flow Graph) `E - N + 2P`
- инструменты вычисляющие ЦС.
  - С++: codalyze VS Code Extension
  - Python: radon

Диссонансом стало различие ЦС вычисленной вручную и инструментом, в целом не критично, т.к. разница в единицах.  

Благодаря уменьшению ЦС код становится декларативным и соответсвенно проще для понимания, чётче выражается намерение разработчика.  
Приходится конечно приложить больше умственных усилий, чтобы не хардкодить if else, но оно точно воздастся в дальнейшем. 

Считаю, что применение полиморфизма не качественно проработанно, необходимо подобрать и порефакторить более подходящие примеры.

Полезная метрика, теперь можно на код-ревью подопечных джунов, подкреплять "цифрами" "плохость" кода, не считая "плохость" чисто субъективной.

